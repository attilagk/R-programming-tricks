## Introduction

Functional programming

* enumerators---`lapply`... or extractors like `getElement`, `[` and sequence generators(?) like `seq`
* filters---predicate(?) functions + `Map` or `lapply`
* maps/transducers(?)---any function + `Map` or `lapply`
* accumulators---`Reduce`

## The problem

Suppose we want to turn the *input* vector $v$ into the *output* vector $w$ such that
```
v = (T,F,F,T,T,F,F,F,F,F,F,F,T,F,F,F,T,T,T,T,T,F,F,F,F,T,F,F,T,T) # input
w = (1,0,0,2,2,0,0,0,0,0,0,0,3,0,0,0,4,4,4,4,4,0,0,0,0,5,0,0,6,6) # desired output
```

In general, the input vector $v$ is a (finite) sequence taking values on the binary set, say $\{\mathrm{true},\mathrm{false}\}$ whereas the output vector $w$ is a sequence on integers with the following properties:

* $w$ is of the same length as $v$
* $w_i=0$ if $v_i=\mathrm{false}$; otherwise $w_i>0$
* for the $m$-th contiguous subsequence of $v$ such that $v_i=v_{i+1}=...=v_{i+k}=\mathrm{true}$ and $v_{i-1}=v_{i+k+1}=\mathrm{false}$, where $k\ge 1$, the corresponding subsequence of $w$ is $w_i=w_{i+1}=...=w_{i+k}=m$

We will refer to such "all-true" subsequences of $v$ as $T$-**segments** and the "all-false" subsequences between them as $F$-**segments**.

### Motivating examples

This problem often arises in conjunction with longitudinal data, where we start from a sample $v_1,...,v_n$ of observations on some binary variable $V$ at sites or time points $1\le i\le n$.  TODO: examples

### Data preparation

```{r}
v <- c(T, F, F, T, T, F, F, F, F, F, F, F, T, F, F, F, T, T, T, T, T, F, F, F, F, T, F, F, T, T)
```

## Solution with an iterative strategy

**Iteration** offers a well-known strategy to solving the problem computationally:
```{r}
T.seg.iter <- function(v) {
    w <- w.j <- as.integer(v[1]) # initialize
    for(i in seq(2, length(v))) {
        if(! v[i]) w <- c(w, 0)  # i is in an F-segment
        else {                   # i is in a T-segment
            if(! v[i - 1])       # i is at the start of a T-segment
                w.j <- w.j + 1
            w <- c(w, w.j)
        }
    }
    return(data.frame(v = v, w = w))
}
```

The iterative strategy expressed by `T.seg.iter` is to visit each $v_i$ sequentially $i=1,...,n$ and compute $w_i$ given $v_i$ and the preceding $v_{i-1}$.  But besides $v_{i-1},v_i$ another piece of information is necessary: the number of $T$-segments occurring up to $i-1$ i.e in the subsequence $v_1,...,v_{i-1}$, which is the same as the value of $w_j$, where $j$ indicates the start of the last $T$-segment in $v_1,...,v_{i-1}$ referred to henceforth as *the latest* $T$-segment.

Note that $j\lt i$ and $v_{i-1}$ may or may not be part of the latest $T$-segment.  In both cases $w_i=0$ if $v_i=\mathrm{false}$ otherwise $w_i$ differs between the two cases:  If $v_{i-1}$ is in the latest $T$-segment then so is $v_i$ and thus $w_i=w_j$; but if $v_{i-1}$ is in the latest $F$-segment then $v_i$ *begins* a new $T$-segment, therefore $w_i=w_j+1$.  All these cases appear within the `for` loop of `T.seg.iter`.

The `w.j` in the body of `T.seg.iter` corresponds to $w_j$ and is a **state variable** which dynamically changes with the computational process.  Given the state at step $i$, defined by $v_i$ and $w_j$, the desired $w_j$ is easily computed.

As we see, the strategy works:
```{r}
T.seg.iter(v)
```

In spite of its success and the brevity of its code `T.seg.iter` may be perceived as conceptually convoluted and hence difficult to analyze and debug (if necessary).  The main problem is that `T.seg.iter` lacks the modularity that would facilitate reasoning about the process generated when it is called with some argument `v`.  To achieve a more modular design, we take now an alternative strategy.

## Solution using the functional paradigm

We begin by reformulating the problem.  While we ultimately aim at $w=(1,0,0,2,0,0,...)$ we will first compute $z=(1,-1,-1,2,-2,-2,...)$
```
v = (T, F, F,T,T, F, F, F, F, F, F, F,T, F, F, F,T,T,T,T,T, F, F, F, F,T,F, F,T,T) # input
z = (1,-1,-1,2,2,-2,-2,-2,-2,-2,-2,-2,3,-3,-3,-3,4,4,4,4,4,-4,-4,-4,-4,5,5,-5,6,6) # desired output
```
So each $F$-segment has its unique label, a non-positive integer.  Note that the label of the first $F$-segment would be zero if $v$ didn't begin with a $T$.

Once `z` is computed then it is easy to obtain the desired `w` using the function
```{r}
do.zero <- function(z)
    ifelse(z > 0, z, 0)
```

So why is `z` useful?  Because it removes the burden of having to deal with a state variable

```{r}
df <- data.frame(v = v)
```


```{r}
T.seg.bin <- function(A, B) {
    last.A <- A[nrow(A), ] # last row of A
    helper <- function() { # returns z for B
        if(last.A$v) {
            if(B$v) last.A$z
            else - last.A$z
        } else {
            if(B$v) 1 - last.A$z
            else last.A$z
        }
    }
    B$z <- helper() # replace initial z with correct z
    rbind(A, B) # accumulate: append B to the end of A
}
```

initialize `z`
```{r}
df$z <- integer(length(df$v))
df$z[1] <- as.integer(df$v[1])
```

```{r}
l.df <- lapply(seq_len(nrow(df)), function(i) df[i, ])
l.df[1:2]
```

```{r}
df <- Reduce(T.seg.bin, l.df)
df$z
```

```{r}
T.seg.functional <- function(v, F.as.zero = TRUE, ...) {
    df <- data.frame(v = v)
    df$z <- integer(length(df$v))
    df$z[1] <- as.integer(df$v[1])
    df <- Reduce(T.seg.bin, lapply(seq_len(nrow(df)), function(i) df[i, ]), ...)
    if(F.as.zero)
        data.frame(v = v, w = do.zero(df$z))
    else df
}
```

```{r}
all.equal(T.seg.functional(v), T.seg.iter(v))
```

```{r}
T.seg.functional(v, F.as.zero = FALSE, accumulate = TRUE)[1:3]
```

## Conclusion
