```{r echo=FALSE}
library(lattice)
opts_chunk$set(dpi = 144)
#opts_chunk$set(fig.width = 10)
#lattice.options(default.args = list(as.table = TRUE))
#lattice.options(default.theme = standard.theme)
```

```{r echo=FALSE}
set.seed(13)
iris$X <- iris$Sepal.Length + rnorm(nrow(iris))
```

```{r splom, dev="png", echo=FALSE}
#splom(~ iris[-5])
```

```{r reference, dev="png", echo=FALSE}
#plot(xyplot(Sepal.Length ~ X, data = iris, groups = Species, ylim = range(iris[-5])), split = c(1, 1, 2, 2), more = TRUE)
#plot(xyplot(Sepal.Width ~ X, data = iris, groups = Species, ylim = range(iris[-5])), split = c(2, 1, 2, 2), more = TRUE)
#plot(xyplot(Petal.Length ~ X, data = iris, groups = Species, ylim = range(iris[-5])), split = c(1, 2, 2, 2), more = TRUE)
#plot(xyplot(Petal.Width ~ X, data = iris, groups = Species, ylim = range(iris[-5])), split = c(2, 2, 2, 2), more = TRUE)
```

## Performing sequential reshapes

The next two code blocks represent the *F.D* sequence of two reshapes.  The first reshape is according to *floral part* and the result is assigned to `iris.F`.

```{r}
iris.F <-
    reshape(iris, direction = "long",
            varying = list(c("Sepal.Length", "Petal.Length"), c("Sepal.Width", "Petal.Width")),
            v.names = c("Length", "Width"),
            timevar = "Floral.Part", times = c("Sepal", "Petal"),
            idvar = "id1")
```

Note how the `varying` argument is a list of equal-length vectors whose length is the number of levels (in this case two) of the factor (floral part) according to which we perform the reshape.  That the length of the list is also two is merely a coincidence.  In general the list may be both shorter or longer than each of its own vector components.  The concluding section will discuss how that is related to the crossed factors of the experiments.

The second reshape in the *F.D* sequence is according to *direction* yielding data frame assigned to the name `iris.F.D`.

```{r}
iris.F.D <-
    reshape(iris.F, direction = "long",
            varying = c("Length", "Width"), v.names = "Size",
            timevar = "Direction", times = c("Length", "Width"),
            drop = "id1")
```

As we see, `iris.F.D` structures data in the desired long-format (compare with the most recent table):
```{r}
head(iris.F.D, n = 2)
tail(iris.F.D, n = 2)
```

The next code block performs the reverse sequential reshape *D.F* i.e. first according to *direction* and then according to *floral part*.

```{r}
iris.D <-
    reshape(iris, direction = "long",
            varying = list(c("Sepal.Length", "Sepal.Width"), c("Petal.Length", "Petal.Width")),
            v.names = c("Sepal", "Petal"),
            timevar = "Direction", times = c("Length", "Width"),
            idvar = "id1")
iris.D.F <-
    reshape(iris.D, direction = "long",
            varying = c("Sepal", "Petal"), v.names = "Size",
            timevar = "Floral.Part", times = c("Sepal", "Petal"),
            drop = "id1")
```

The "head" and "tail" of the new data frame `iris.D.F` are the same as those of `iris.D.F` (up to the order of the `Floral.Part` and `Direction` components).

```{r}
head(iris.D.F, n = 2)
iris.D.F[201, ]
tail(iris.D.F, n = 2)
```

But the middle portion of the two data frames differ due to the different permutation of crossed factors.
```{r}
iris.F.D[201, ]
iris.D.F[201, ]
```

## The goal attained

Having sequentially shaped the *Iris* data---supplemented with our covariate $X$---into two long-format data frames, we are ready to produce the trellis display.  Starting with `iris.F.D` (resulting from the "forward" sequence)
```{r correct.F, dev="png"}
xyplot(Size ~ X | Direction * Floral.Part, data = iris.F.D, groups = Species, auto.key = list(columns = 3))
```

Using `iris.D.F` ("reverse" sequence) yields
```{r correct.D, dev="png"}
xyplot(Size ~ X | Direction * Floral.Part, data = iris.D.F, groups = Species, auto.key = list(columns = 3))
```

The two plots are identical since the differences between `iris.F.D` and `iris.D.F`---or equivalently between the corresponding sequences of reshapes---are immaterial from the viewpoint of `xyplot`, as discussed earlier.

## How to call `reshape` and why so?

The crucial but poorly documented feature of `reshape` is how "time"-varying variables must be specified for the `varying` argument in factorial experiments like the *Iris* study.  Suppose there are $k$ factors  $a_1,...,a_k$, whose levels count $p_{a_1},...,p_{a_k}$ (as we saw these factors are equivalent to index sets $\mathcal{V}_{a_1},...,\mathcal{V}_{a_k}$).  With the notation we introduced for longitudinal setups $\prod_{i=1}^k p_{a_1} = p\le n$ because we have a fully crossed design.  The remaining $q\equiv n - p$ variables, if any, play a passive role in any of the reshapes.  In our extended *Iris* example $p_\mathrm{sp} = 3, \; p_\mathrm{fp} = 2, \; p_\mathrm{dir} = 2$ and finally, for covariate $X$, $q=1$.

Imagine that our data are in a completely wide format so that a sequence of $k$ reshapes must be used to reach the (completely) long format.  Clearly, the sequence of reshapes follows a chosen sequence of factors $a_1,...,a_k$.

First we want to reshape according to factor $a_1$ (equivalently index set $\mathcal{V}_{a_1}$.  With what arguments should we call `reshape`?  In particular what should be the value of the `varying` argument?  Some experimentation shows that `varying` must be a list of character vectors each of length $p_{a_1}$ because all $p_{a_1}$ levels of factor $a_1$ must appear in each vector.  The number of such vectors---the length of the list itself---is $p / p_{a_1} = \prod_{i=2}^k p_{a_i}$ because we need to consider all combinations of the *remaining* $k-1$ factors.  In the second reshape $a_1$ plays no more role so it is omitted from `varying`.  Now the list has $p / (p_{a_1} p_{a_2}) = \prod_{i=3}^k p_{a_i}$ vector components and each vector is $p_{a_2}$ long.  The sequence continues with $i=3,...,k$.

If we follow this rule then the last, $k$-th, reshape is special in the sense that `varying` is a list with a single component, a $p_{a_k}$-length vector since there are no more factors to combine.  Therefore this trivial list may be `unlist`ed: replaced by its only component (the $p_{a_k}$-length vector) without any loss of information.  In fact, this is probably by far the most frequent way in which `reshape` is called since it was designed for longitudinal experiments where with only $k=1$ "factor" present: time.

## The lessons learned

The multiplicity of data representations is not only computationally convenient but also facilitates the clarification and expression of certain semantic relationships between variables.  Unlike `stack` the `reshape` function allows representation of various experimental setups by partitioning variables into related sets and indexing those separately.  We only briefly mentioned how longitudinal setups can be modeled with `reshape` and how this can be generalized to cases where instead of time points genes or other objects serve as indices to a set of related variables. `reshape`'s documentation provides details and examples on---possibly generalized---longitudinal applications.

In contrast, we examined more deeply how `reshape` is also capable of dealing with the equally important but more complex case of factorial experiments, where $k$ number of combined index sets correspond to $k$ crossed factors.  In the *Iris* data set the factors are *species*, *floral part*, and measurement *direction* so $k=3$.  Moreover, we supplemented `iris` with a covariate $X$ with the intention of $X$ having a relation to the original variables akin to time-invariant variables relate time-varying ones in longitudinal studies in a sense that data reshaping is only governed by the latter.  This demonstrated how flexibly `reshape` can be adapted to various setups.

We also saw that as many reshapes can be performed as many factors are present.  Therefore various *sequences* of reshapes may transform a completely wide-format data frame to a completely long-format one.  Thus, intermediate formats exist whenever we have $k>2$ factors.  Which sequence of reshapes we chose is immaterial, or at least should be, from the viewpoint of well-designed software such as the trellis display plotting `xyplot`.
